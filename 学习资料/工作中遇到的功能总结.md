# 工作中遇到的功能总结

## 通过Http接口上传附件

1. 添加依赖
   
   ```xml
           <dependency>
               <groupId>org.apache.httpcomponents</groupId>
               <artifactId>httpclient</artifactId>
               <version>4.5.13</version>
           </dependency>
   
           <dependency>
               <groupId>org.apache.httpcomponents</groupId>
               <artifactId>httpmime</artifactId>
               <version>4.5.13</version>
           </dependency>
   ```

2. 实现类
   
   ```java
    /**
        * 上传文件
        *
        * @param postUrl 提交url
        * @param files 上传的文件集合
        * @param params 其他参数集合
        * @return 返回提交结果
        */
       public static String multipartFormDataRequest(String postUrl, Map<String, File> files, Map<String, String> params) {
   
           String retStr = "";
           CloseableHttpClient httpClient = HttpClients.createDefault();
           try {
               MultipartEntityBuilder builder = MultipartEntityBuilder.create();
               files.forEach((k, file) -> {
                   if (StringUtils.hasText(k) && file != null) {
                       try {
                           builder.addBinaryBody(k, Files.newInputStream(file.toPath()), ContentType.MULTIPART_FORM_DATA, file.getName());
                       } catch (IOException e) {
                           throw new RuntimeException(e);
                       }
                   }
               });
   
               //参数设置编码utf-8，不然中文会乱码
               ContentType contentType = ContentType.create("text/plain", StandardCharsets.UTF_8);
   
               params.forEach((k, v) -> {
                   if (StringUtils.hasText(k) && StringUtils.hasText(v)) {
                       builder.addTextBody(k, v, contentType);
                   }
               });
               HttpEntity entity = builder.build();
               HttpPost httpPost = new HttpPost(postUrl);
               httpPost.setEntity(entity);
               HttpResponse response = httpClient.execute(httpPost);
               HttpEntity responseEntity = response.getEntity();
               if (responseEntity != null) {
                   // 将响应内容转换为字符串
                   retStr = EntityUtils.toString(responseEntity, StandardCharsets.UTF_8);
               }
           } catch (IOException e) {
               e.printStackTrace();
           } catch (Exception e) {
               e.printStackTrace();
           } finally {
               try {
                   httpClient.close();
               } catch (IOException e) {
                   e.printStackTrace();
               }
           }
           return retStr;
       }
   ```

3. 调用例子：
   
   ```java
    public String addDocument(KnowledgeEntity knowledgeEntity, File[] fileList) {
           Map<String, String> paramMap = new HashMap<>();
           paramMap.put("fdDocTemplateId", knowledgeEntity.getFdDocTemplateId() == null ?
                   KnowledgeConsts.DEFAULT_FD_DOC_TEMPLATE_ID : knowledgeEntity.getFdDocTemplateId());
           paramMap.put("docSubject", knowledgeEntity.getDocSubject());
           paramMap.put("docContent", knowledgeEntity.getDocContent());
           paramMap.put("authorType", knowledgeEntity.getDocAuthorType() == null ?
                   KnowledgeConsts.DEFAULT_DOC_AUTHOR_TYPE : knowledgeEntity.getDocAuthorType());
           paramMap.put("docAuthor", knowledgeEntity.getDocAuthor());
           paramMap.put("fdDocCreator", knowledgeEntity.getFdDocCreator());
   
           File files = new File(KnowledgeConsts.FILE_DIR + knowledgeEntity.getDocSubject());
           fileList = files.listFiles();
           Map<String, File> fileMap = new HashMap<>();
           AttachmentForms[] arrayAttachmentForms = new AttachmentForms[fileList.length];
           for (int i = 0; i < arrayAttachmentForms.length; i++) {
               paramMap.put("attachmentForms[" + i + "].fdKey", KnowledgeConsts.DEFAULT_FD_KEY);
               paramMap.put("attachmentForms[" + i + "].fdFileName", fileList[i].getName());
               fileMap.put("attachmentForms[" + i + "].fdAttachment", fileList[i]);
           }
           logger.debug("新增文档接口提交报文{}", paramMap);
           String result = HttpClientUtil.multipartFormDataRequest(KnowledgeConsts.BASE_URL + KnowledgeRequestEnum.KNOWLEDGE_ADD.getValue(), fileMap, paramMap);
           logger.debug("新增文档接口返回报文{}", result);
           return result;
       }
   ```

### 文件名乱码解决：

```java
builder.addBinaryBody(k, Files.newInputStream(file.toPath()), ContentType.MULTIPART_FORM_DATA, file.getName());
```

这样调用，如果是中文的文件名字会乱码。需要我们设置一下mode

MultipartEntityBuilder builder = MultipartEntityBuilder.create();  
builder.setMode(HttpMultipartMode.RFC6532);

这样就不会乱码了。

## Base64代替类

1. com.sun.org.apache.xerces.internal.impl.dv.util.Base64是内部专用 API, 可能会在未来发行版中删除
   
   decoder 改为：
   
   ```java
   new BASE64Decoder().decodeBuffer(str);
   ```
   
   encoder改为
   
   ```java
   new BASE64Encoder().encoder(byte[]);
   ```
   
   但是这样会有一个新的问题，这个BASE64Encoder在sun.misc包中，sun.misc包中的都是sun公司的内部类，并没有在java [api](https://so.csdn.net/so/search?q=api&spm=1001.2101.3001.7020)中公开过，不建议使用，所以使用这些方法是不安全的，将来随时可能会从中去除，所以相应的应该使用替代的对象及方法

2. 自己编写一个util类
   
   ```java
   package com.xt.transfer.utils;
   
   import org.apache.commons.codec.binary.Base64;
   
   public class Base64Util {
       /**
        * @param bytes
        * @return
        */
       public static byte[] decode(final byte[] bytes) {
           return Base64.decodeBase64(bytes);
       }
   
       /**
        * 字符串转换为base64字节数组
        * @param str
        * @return
        */
       public static byte[] decode(String str) {
           return Base64.decodeBase64(str);
       }
   
       /**
        * 二进制数据编码为BASE64字符串
        *
        * @param bytes
        * @return
        * @throws Exception
        */
       public static String encode(final byte[] bytes) {
           return new String(Base64.encodeBase64(bytes));
       }
   }
   ```

```java
## base64字符串转⽂件

1.  utils类

```java
package com.xt.transfer.utils;

import com.xt.transfer.KnowledgeConsts;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;

public class FileUtil {

    public static void decryptByBase64(byte[] bytes, String filePath, String outputFileName) {
        if (bytes == null && filePath == null) {
            return;
        }
        try {
            Files.write(Paths.get(filePath + outputFileName), bytes, StandardOpenOption.CREATE);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * base64字符串转⽂件
     *
     * @return
     */
    public static File base64ToFile(byte[] bytes, String fileDir, String outputFileName) {
        FileOutputStream out = null;
        try {
            // 不管目录是否存在，都创建
            new File(fileDir).mkdir();
            // 解码，然后将字节转换为⽂件
            File file = new File(fileDir, outputFileName);
            file.createNewFile();
            out = new FileOutputStream(file);
            ByteArrayInputStream in = new ByteArrayInputStream(bytes);
            byte[] buffer = new byte[1024];
            int byteRead;
            while ((byteRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, byteRead); // ⽂件写操作
            }
            return file;
        } catch (IOException ioe) {
            ioe.printStackTrace();
            return null;
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

## Sigar

### 地址

Hyperic-hq官方网站：[http://www.hyperic.com](http://www.hyperic.com/)

Sigar.jar下载地址：http://sourceforge.net/projects/sigar/files/

Sigar.jar文档地址：https://support.hyperic.com/display/SIGAR/Home

### 介绍

Sigar全名是System Information Gatherer And Reporter，中文名是系统信息收集和报表工具。我是一个开源的工具，提供了跨平台的系统信息收集的API ,是Hyperic-hq产品的基础包，是Hyperic HQ主要的数据收集组件。它用来从许多平台收集系统和处理信息。

这些平台包括：Linux，Windows，Solaris，AIX，HP-UX，FreeBSD和Mac OSX。

**可以收集的信息**

- CPU信息：包括基本信息（vendor、model、mhz、cacheSize）和统计信息（user、sys、idle、nice、wait）
- 文件系统信息：包括Filesystem、Size、Used、Avail、Use%、Type
- 事件信息：类似Service Control Manager
- 内存信息：物理内存和交换内存的总数、使用数、剩余数；RAM的大小
- 网络信息：包括网络接口信息和网络路由信息
- 进程信息：包括每个进程的内存、CPU占用数、状态、参数、句柄
- IO信息：包括IO的状态，读写大小等
- 服务状态信息
- 系统信息：包括操作系统版本，系统资源限制情况，系统运行时间以及负载，JAVA的版本信息等

## Docker安装oracle数据库

1. 启动docker并设置开机启动
   
   `sudo systemctl start docker`
   
   `sudo systemctl enable docker`
   
   先pull下来oracle镜像
   
   拉取docker镜像：  
   docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g

2. 运行镜像
   
   docker run -d -p 1521:1521 --name oracle registry.aliyuncs.com/helowin/oracle_11g

3. 启动
   
   docker start oracle

4. 配置环境变量
   
   vi /etc/profile
   
   export ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2
   export ORACLE_SID=helcwin
   export PATH=$ORACLE_HOME/bin:$PATH
   
   source /etc/profile

5. 进入oracle
   
   docker exec -it oracle bash
   
   source ~/.bash_profile

6. 设置oracle
   
   sqlplus /nolog;
   
   conn / as sysdba;

7. 创建表空间
   
   create tablespace ecology datafile '/home/oracle/app/oracle/oradata/helowin/ecology.dbf' size 2000M AutoExtend On Next 10M segment space management auto;

8. 创建用户
   
   CREATE USER ecology IDENTIFIED BY ecology DEFAULT TABLESPACE ecology TEMPORARY TABLESPACE Temp;

9. 赋权限
   
   grant connect,resource to ecology;
   
   grant create view to ecology;
   
   grant DATAPUMP_EXP_FULL_DATABASE ,DATAPUMP_IMP_FULL_DATABASE to ecology;
   
   alter system set "_allow_level_without_connect_by" = true;

<<<<<<< HEAD
## SpringBoot 参数验证

**特别注意：**一定要定义的全局异常类和启动类在同一个包下，要不然全局异常类不起作用。

1. 依赖

   ```xml
      <dependency>
         <groupId>org.springframework.boot</groupId>
         <artifactId>spring-boot-starter-validation</artifactId>
       </dependency>
   ```

   

2. 注解

   ```java
   public class SystemBusinessDataVO {
   
       private Integer id;
   
       @NotBlank(message = "code不能为空")
       private String code;
   
       @NotBlank(message = "name不能为空")
       private String name;
   
       @NotBlank(message = "value不能为空")
       private String value;
   
       @NotBlank(message = "序号不能为空")
       private Integer sortId;
   
       private String status;
   
       private String typeCode;
   }
   ```

   

3. 异常处理

   ```java
   package com.wjl.common;
   
   import io.jsonwebtoken.JwtException;
   import java.nio.file.AccessDeniedException;
   import javax.validation.ConstraintViolationException;
   import org.slf4j.Logger;
   import org.slf4j.LoggerFactory;
   import org.springframework.http.HttpStatus;
   import org.springframework.validation.BindException;
   import org.springframework.validation.BindingResult;
   import org.springframework.validation.ObjectError;
   import org.springframework.web.bind.MethodArgumentNotValidException;
   import org.springframework.web.bind.annotation.ExceptionHandler;
   import org.springframework.web.bind.annotation.ResponseStatus;
   import org.springframework.web.bind.annotation.RestControllerAdvice;
   
   @RestControllerAdvice
   public class GlobalException {
   
       private final Logger logger = LoggerFactory.getLogger(GlobalException.class);
   
       @ResponseStatus(HttpStatus.BAD_REQUEST)
       @ExceptionHandler(IllegalArgumentException.class)
       public ResultJson handler(IllegalArgumentException e) {
           logger.error("Assert异常：---------{}", e.getMessage());
           return ResultJson.fail(e.getMessage());
       }
   
       @ResponseStatus(HttpStatus.OK)
       @ExceptionHandler(RuntimeException.class)
       public ResultJson handler(RuntimeException e) {
           logger.error("运行时异常：---------{}", e.getMessage());
           return ResultJson.fail(e.getMessage());
       }
   
       @ResponseStatus(HttpStatus.FORBIDDEN)
       @ExceptionHandler(AccessDeniedException.class)
       public ResultJson handler(AccessDeniedException e) {
           logger.error("security权限不足：-------{}", e.getMessage());
           return ResultJson.fail(e.getMessage());
       }
   
       @ResponseStatus(HttpStatus.BAD_REQUEST)
       @ExceptionHandler(MethodArgumentNotValidException.class)
       public ResultJson handler(MethodArgumentNotValidException e) {
           logger.error("实体校验异常：---------{}", e.getMessage());
           BindingResult bindingResult = e.getBindingResult();
           ObjectError objectError = bindingResult.getAllErrors().stream().findFirst().get();
           return ResultJson.error(HttpStatus.BAD_REQUEST.value(), objectError.getDefaultMessage());
       }
   
       @ResponseStatus(HttpStatus.BAD_REQUEST)
       @ExceptionHandler(BindException.class)
       public ResultJson handler(BindException bindException){
           logger.error("bindException：-------{}", bindException.getMessage());
           return ResultJson.error(HttpStatus.BAD_REQUEST.value(),
               bindException.getAllErrors().stream().findFirst().get().getDefaultMessage());
       }
   
       @ResponseStatus(HttpStatus.BAD_REQUEST)
       @ExceptionHandler(BindException.class)
       public ResultJson handler(ConstraintViolationException ex){
           logger.error("ConstraintViolationException：-------{}", ex.getMessage());
           return ResultJson.error(HttpStatus.BAD_REQUEST.value(), ex.getMessage());
       }
   
       @ResponseStatus(HttpStatus.OK)
       @ExceptionHandler(JwtException.class)
       public ResultJson handler(JwtException e) {
           logger.error("token异常：------{}", e.getMessage());
           return ResultJson.fail(e.getMessage());
       }
   }
   
   ```

4. controller调用

   ```java
      @PostMapping("update")
       public ResultJson update(@RequestBody @Valid SystemBusinessTypeVO businessTypeVO) {
           if (systemBusinessTypeService.updateById(businessTypeVO) > 0) {
               return ResultJson.success();
           }
           return ResultJson.fail("更新数据字典类型失败");
       }
   ```

   
=======
## java爬虫

### 登录功能

#### 使用HTTPClient实现

- 需求场景
  
  使用httpClient调用登录，实现和页面登录相同功能，使得可以访问需要登录的资源。这种一般是因为后面的访问资源需要登录才能访问，我们通过登录以后拿到cookie，访问后面的资源带着这个cookie就可访问了
  
  - 实现
    
    1、如果是maven项目需要引入依赖，如果是普通java项目需要自己下载jar包
    
    ```xml
            <dependency>
                <groupId>commons-httpclient</groupId>
                <artifactId>commons-httpclient</artifactId>
                <version>3.1</version>
                <scope>test</scope>
            </dependency>
    ```
    
    2、代码实现
    
    ```java
    package com.xt.transfer;
    
    import com.alibaba.fastjson2.JSONObject;
    import com.xt.transfer.utils.HttpClientUtil;
    import com.xt.transfer.utils.RSAUtil;
    import org.apache.commons.httpclient.Cookie;
    import org.apache.commons.httpclient.HttpClient;
    import org.apache.commons.httpclient.NameValuePair;
    import org.apache.commons.httpclient.cookie.CookiePolicy;
    import org.apache.commons.httpclient.methods.GetMethod;
    import org.apache.commons.httpclient.methods.PostMethod;
    
    import javax.crypto.BadPaddingException;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.spec.InvalidKeySpecException;
    
    public class HttpLoginTest {
    
        public  static  void  main(String[] args) throws NoSuchPaddingException, IllegalBlockSizeException, NoSuchAlgorithmException, BadPaddingException, InvalidKeySpecException, InvalidKeyException {
            // 登陆 Url
            String loginUrl =  "http://elearning.hr.suntien.com/volbeacon/login/login.do" ;
            HttpClient httpClient =  new HttpClient();
    
            // 模拟登陆，按实际服务器端要求选用 Post 或 Get 请求方式
            PostMethod postMethod =  new  PostMethod(dataUrl);
    
            // 设置登陆时要求的信息，用户名和密码
            NameValuePair[] data = {new NameValuePair("abc", "lishaohui"),
                    new NameValuePair("loginId", loginId),
                    new NameValuePair("passwordEncryption", encryptPassword),
                    new NameValuePair("execute", "1"),
                    new NameValuePair("loginType", "1"),
                    new NameValuePair("type", "2"),
                    new NameValuePair("ip", "106.113.23.11"),
                    new NameValuePair("cityName","河北省石家庄市"),
                    new NameValuePair("administrativeCode","130100")};
            postMethod.setRequestBody(data);
            try  {
                // 设置 HttpClient 接收 Cookie,用与浏览器一样的策略
                httpClient.getParams().setCookiePolicy(CookiePolicy.BROWSER_COMPATIBILITY);
                int statusCode=httpClient.executeMethod(postMethod);
    
                // 获得登陆后的 Cookie
                Cookie[] cookies = httpClient.getState().getCookies();
                StringBuffer tmpcookies =  new  StringBuffer();
                for  (Cookie c : cookies) {
                    tmpcookies.append(c.toString() +  ";" );
                    System.out.println( "cookies = " +c.toString());
                }
                if (statusCode== 303 || statusCode== 302){ //重定向到新的URL
                    System.out.println( "模拟登录成功" );
                    // 进行登陆后的操作 重定向的url
                    GetMethod getMethod =  new  GetMethod("http://elearning.hr.suntien.com/volbeacon/study/home/home.do");
                    // 每次访问需授权的网址时需带上前面的 cookie 作为通行证
                    getMethod.setRequestHeader( "cookie" , tmpcookies.toString());
    
                    postMethod.setRequestHeader( "Referer" ,  "http://passport.mop.com/" );
                    postMethod.setRequestHeader( "User-Agent" ,  "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36" );
                    httpClient.executeMethod(getMethod);
                    // 打印出返回数据，检验一下是否成功
                    String text = getMethod.getResponseBodyAsString();
                    System.out.println(text);
                }
                else  {
                    System.out.println( "登录失败" );
                }
            }
            catch  (Exception e) {
                e.printStackTrace();
            }
        }
    }
    ```
    
    ```
    
    ```

这个问题浪费了我很多的时间，最终才解决。主要是获取cookie这里。

#### 使用Forest实现

##### Forest介绍：

官网：https://forest.dtflyx.com/

声明式HTTP客户端框架，减轻您的开发负担

##### maven依赖

```xml
         <dependency>
            <groupId>com.dtflys.forest</groupId>
            <artifactId>forest-spring-boot-starter</artifactId>
            <version>1.5.26</version>
        </dependency>
```

##### 代码实现

```java

```

### 获取列表
>>>>>>> f0669fb905e8f7bcd8cebf6f60ad712e87597eb7

## 文章收藏

[【Spring Boot】Spring Boot使用线程池处理上万条数据插入 - 掘金](https://juejin.cn/post/7129470167607672840)

## Map排序

```java
   private static Map<String, Integer> sortMapByValue(Map<String, Integer> map){
        Map<String, Integer> result = new HashMap<>();
        // 升序
        //map.entrySet().stream().sorted(Map.Entry.comparingByValue()).forEachOrdered(i->result.put(i.getKey(), i.getValue()));
        // 降序
        map.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue())).forEachOrdered(i->result.put(i.getKey(), i.getValue()));
        return result;
    }
```

**JSON是JavaScript Object Notation 的缩写**

## 修改linuxIP地址

vim /etc/sysconfig/network-scripts/ifcfg-ens3

## linux系统访问url

curl -X POST -d parama=a&paramb=b "url"

curl -l -H 'Content-type: application/json' -X POST -d '{"rumenz":"123"}' "https://json.im/123.json"

## Docker安装ElasticSearch集群环境

1. 首先安装有docker: [Docker overview | Docker Documentation](https://docs.docker.com/get-started/overview/)

2. 在docker中安装ElasticSearch集群
   
   1. 拉取镜像
      
      启动docker以后执行命令
      
      ```bash
      docker pull docker.elastic.co/elasticsearch/elasticsearch:8.5.3
      ```
      
      ```bash
      docker images
      ```
   
   2. 安装docker compose
      
      我这里安装的是comopse-plugin
      
      ```bash
      sudo yum update
      sudo yum install docker-compose-plugin
      ```
      
      验证是否安装成功
      
      ```bash
      docker compose version
      ```
   
   3. 准备环境
      
      - 在某目录下创建开一个目录，作为这个项目的目录
      
      - 在项目根目录下创建配置文件.evn
        
        ```properties
        # Password for the 'elastic' user (at least 6 characters)
        ELASTIC_PASSWORD=elastic
        
        # Password for the 'kibana_system' user (at least 6 characters)
        KIBANA_PASSWORD=kibana
        
        # Version of Elastic products
        STACK_VERSION=8.5.3
        
        # Set the cluster name
        CLUSTER_NAME=docker-cluster
        
        # Set to 'basic' or 'trial' to automatically start the 30-day trial
        #LICENSE=basic
        #LICENSE=trial
        
        # Port to expose Elasticsearch HTTP API to the host
        ES_PORT=9200
        #ES_PORT=127.0.0.1:9200
        
        # Port to expose Kibana to the host
        KIBANA_PORT=5601
        #KIBANA_PORT=80
        
        # Increase or decrease based on the available host memory (in bytes)
        MEM_LIMIT=1073741824
        
        # Project namespace (defaults to the current folder name if not set)
        #COMPOSE_PROJECT_NAME=myproject
        ```
      
      - 创建配置文件docker-compose.yml
        
        ```yml
        version: "2.2"
        
        services:
          setup:
            image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
            volumes:
              - certs:/usr/share/elasticsearch/config/certs
            user: "0"
            command: >
              bash -c '
                if [ x${ELASTIC_PASSWORD} == x ]; then
                  echo "Set the ELASTIC_PASSWORD environment variable in the .env file";
                  exit 1;
                elif [ x${KIBANA_PASSWORD} == x ]; then
                  echo "Set the KIBANA_PASSWORD environment variable in the .env file";
                  exit 1;
                fi;
                if [ ! -f config/certs/ca.zip ]; then
                  echo "Creating CA";
                  bin/elasticsearch-certutil ca --silent --pem -out config/certs/ca.zip;
                  unzip config/certs/ca.zip -d config/certs;
                fi;
                if [ ! -f config/certs/certs.zip ]; then
                  echo "Creating certs";
                  echo -ne \
                  "instances:\n"\
                  "  - name: es01\n"\
                  "    dns:\n"\
                  "      - es01\n"\
                  "      - localhost\n"\
                  "    ip:\n"\
                  "      - 127.0.0.1\n"\
                  "  - name: es02\n"\
                  "    dns:\n"\
                  "      - es02\n"\
                  "      - localhost\n"\
                  "    ip:\n"\
                  "      - 127.0.0.1\n"\
                  "  - name: es03\n"\
                  "    dns:\n"\
                  "      - es03\n"\
                  "      - localhost\n"\
                  "    ip:\n"\
                  "      - 127.0.0.1\n"\
                  > config/certs/instances.yml;
                  bin/elasticsearch-certutil cert --silent --pem -out config/certs/certs.zip --in config/certs/instances.yml --ca-cert config/certs/ca/ca.crt --ca-key config/certs/ca/ca.key;
                  unzip config/certs/certs.zip -d config/certs;
                fi;
                echo "Setting file permissions"
                chown -R root:root config/certs;
                find . -type d -exec chmod 750 \{\} \;;
                find . -type f -exec chmod 640 \{\} \;;
                echo "Waiting for Elasticsearch availability";
                until curl -s --cacert config/certs/ca/ca.crt https://es01:9200 | grep -q "missing authentication credentials"; do sleep 30; done;
                echo "Setting kibana_system password";
                until curl -s -X POST --cacert config/certs/ca/ca.crt -u "elastic:${ELASTIC_PASSWORD}" -H "Content-Type: application/json" https://es01:9200/_security/user/kibana_system/_password -d "{\"password\":\"${KIBANA_PASSWORD}\"}" | grep -q "^{}"; do sleep 10; done;
                echo "All done!";
              '
            healthcheck:
              test: ["CMD-SHELL", "[ -f config/certs/es01/es01.crt ]"]
              interval: 1s
              timeout: 5s
              retries: 120
        
          es01:
            depends_on:
              setup:
                condition: service_healthy
            image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
            volumes:
              - certs:/usr/share/elasticsearch/config/certs
              - esdata01:/usr/share/elasticsearch/data
            ports:
              - ${ES_PORT}:9200
            environment:
              - node.name=es01
              - cluster.name=${CLUSTER_NAME}
              - cluster.initial_master_nodes=es01,es02,es03
              - discovery.seed_hosts=es02,es03
              - ELASTIC_PASSWORD=${ELASTIC_PASSWORD}
              - bootstrap.memory_lock=true
              - xpack.security.enabled=true
              - xpack.security.http.ssl.enabled=true
              - xpack.security.http.ssl.key=certs/es01/es01.key
              - xpack.security.http.ssl.certificate=certs/es01/es01.crt
              - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
              - xpack.security.http.ssl.verification_mode=certificate
              - xpack.security.transport.ssl.enabled=true
              - xpack.security.transport.ssl.key=certs/es01/es01.key
              - xpack.security.transport.ssl.certificate=certs/es01/es01.crt
              - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
              - xpack.security.transport.ssl.verification_mode=certificate
            mem_limit: ${MEM_LIMIT}
            ulimits:
              memlock:
                soft: -1
                hard: -1
            healthcheck:
              test:
                [
                  "CMD-SHELL",
                  "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'",
                ]
              interval: 10s
              timeout: 10s
              retries: 120
        
          es02:
            depends_on:
              - es01
            image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
            volumes:
              - certs:/usr/share/elasticsearch/config/certs
              - esdata02:/usr/share/elasticsearch/data
            environment:
              - node.name=es02
              - cluster.name=${CLUSTER_NAME}
              - cluster.initial_master_nodes=es01,es02,es03
              - discovery.seed_hosts=es01,es03
              - bootstrap.memory_lock=true
              - xpack.security.enabled=true
              - xpack.security.http.ssl.enabled=true
              - xpack.security.http.ssl.key=certs/es02/es02.key
              - xpack.security.http.ssl.certificate=certs/es02/es02.crt
              - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
              - xpack.security.http.ssl.verification_mode=certificate
              - xpack.security.transport.ssl.enabled=true
              - xpack.security.transport.ssl.key=certs/es02/es02.key
              - xpack.security.transport.ssl.certificate=certs/es02/es02.crt
              - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
              - xpack.security.transport.ssl.verification_mode=certificate
            mem_limit: ${MEM_LIMIT}
            ulimits:
              memlock:
                soft: -1
                hard: -1
            healthcheck:
              test:
                [
                  "CMD-SHELL",
                  "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'",
                ]
              interval: 10s
              timeout: 10s
              retries: 120
        
          es03:
            depends_on:
              - es02
            image: docker.elastic.co/elasticsearch/elasticsearch:${STACK_VERSION}
            volumes:
              - certs:/usr/share/elasticsearch/config/certs
              - esdata03:/usr/share/elasticsearch/data
            environment:
              - node.name=es03
              - cluster.name=${CLUSTER_NAME}
              - cluster.initial_master_nodes=es01,es02,es03
              - discovery.seed_hosts=es01,es02
              - bootstrap.memory_lock=true
              - xpack.security.enabled=true
              - xpack.security.http.ssl.enabled=true
              - xpack.security.http.ssl.key=certs/es03/es03.key
              - xpack.security.http.ssl.certificate=certs/es03/es03.crt
              - xpack.security.http.ssl.certificate_authorities=certs/ca/ca.crt
              - xpack.security.http.ssl.verification_mode=certificate
              - xpack.security.transport.ssl.enabled=true
              - xpack.security.transport.ssl.key=certs/es03/es03.key
              - xpack.security.transport.ssl.certificate=certs/es03/es03.crt
              - xpack.security.transport.ssl.certificate_authorities=certs/ca/ca.crt
              - xpack.security.transport.ssl.verification_mode=certificate
            mem_limit: ${MEM_LIMIT}
            ulimits:
              memlock:
                soft: -1
                hard: -1
            healthcheck:
              test:
                [
                  "CMD-SHELL",
                  "curl -s --cacert config/certs/ca/ca.crt https://localhost:9200 | grep -q 'missing authentication credentials'",
                ]
              interval: 10s
              timeout: 10s
              retries: 120
        
          kibana:
            depends_on:
              es01:
                condition: service_healthy
              es02:
                condition: service_healthy
              es03:
                condition: service_healthy
            image: docker.elastic.co/kibana/kibana:${STACK_VERSION}
            volumes:
              - certs:/usr/share/kibana/config/certs
              - kibanadata:/usr/share/kibana/data
            ports:
              - ${KIBANA_PORT}:5601
            environment:
              - SERVERNAME=kibana
              - ELASTICSEARCH_HOSTS=https://es01:9200
              - ELASTICSEARCH_USERNAME=kibana_system
              - ELASTICSEARCH_PASSWORD=${KIBANA_PASSWORD}
              - ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES=config/certs/ca/ca.crt
            mem_limit: ${MEM_LIMIT}
            healthcheck:
              test:
                [
                  "CMD-SHELL",
                  "curl -s -I http://localhost:5601 | grep -q 'HTTP/1.1 302 Found'",
                ]
              interval: 10s
              timeout: 10s
              retries: 120
        
        volumes:
          certs:
            driver: local
          esdata01:
            driver: local
          esdata02:
            driver: local
          esdata03:
            driver: local
          kibanadata:
            driver: local
        ```
        
        三个节点的集群和一个kibana
      
      - 注意，修改配置
        
        linux系统需要修改一个配置：
        
        ```properties
        vim /etc/sysctl.conf
        ```
        
        增加配置：
        
        ```properties
        vm.max_map_count=262144
        ```
   
   4. 启动集群
      
      ```bash
      docker-compose up -d
      
      docker-compose start
      ```
      
      停止服务
      
      ```bash
      docker-compose down
      docker-compose stop
      ```

docker查看日志：

docker compose -f docker-compose.yml logs -f

## Apache APISIX

https://apisix.apache.org/

## docker容器复制文件到宿主机

docker cp 容器id:容器中文件的路径 宿主机路径

相反，从宿主机拷贝文件到容器

docker cp 宿主机文件 容器id:容器中文件的路径  

## 动态代理

```java
package com.xt.test.example;

public interface Calculate {

    int add(int i, int j);

    int subtract(int i, int j);

    int multiply(int i, int j);

    int divide(int i, int j);
}
```

```java
package com.xt.test.example;

public class CalculateImpl implements Calculate {

    @Override
    public int add(int i, int j) {
        System.out.println("加法被调用");
        return i + j;
    }

    @Override
    public int subtract(int i, int j) {
        System.out.println("减法被调用");
        return i - j;
    }

    @Override
    public int multiply(int i, int j) {
        System.out.println("乘法被调用");
        return i * j;
    }

    @Override
    public int divide(int i, int j) {
        System.out.println("除法被调用");
        return i / j;
    }
}
```

```java
package com.xt.test.example;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class ProxyFactory {

    private Object target;

    public ProxyFactory(Object target) {

        this.target = target;
    }

    public Object getProxy() {

        ClassLoader classLoader = target.getClass().getClassLoader();

        Class<?>[] interfaces = target.getClass().getInterfaces();

        InvocationHandler invocationHandler = (obj, method, args) -> {

            System.out.println("调用方法前");

            Object result = method.invoke(target, args);

            System.out.println("调用方法后");

            return result;
        };

        return Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);
    }


}
```

```java
package com.xt.employee;

import com.xt.test.example.Calculate;
import com.xt.test.example.CalculateImpl;
import com.xt.test.example.ProxyFactory;

public class TestProxy {

    public static void main(String[] args) {

        ProxyFactory proxyFactory = new ProxyFactory(new CalculateImpl());
        Calculate calculate =  (Calculate)proxyFactory.getProxy();
        System.out.println(calculate.add(1, 3));
    }
}
```

# Springboot3.0整合swagger，废弃Springfox改用Springdoc

## 什么是Springfox

Automated JSON API documentation for API's built with Spring

官网地址：springfox.io

## 什么是Springdoc

`springdoc-openapi` java library helps to automate the generation of API documentation using spring boot projects.

官网地址：https://springdoc.org/v2/

**注意**：使用的是V2版本，这个版本支持springboot3.0

## 为什么改用springdoc

之前springboot3.0之前我用的都是Springfox来集成Swagger管理我们的API接口文档，这也就是Springfox和Springdoc最主要的功能。因为Springfox已经停止更新有段时间了，升级Springboot3.0以后会有更多问题暴露出来。Spring官网推荐了Springdoc，应该不会短时间停更，所以改用Springdoc

## 具体实现

Springdoc使用也很简单，基本上也是开箱即用，不需要任何的配置，直接就可以使用。

首先添加依赖：

```xml
   <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
      <version>2.0.2</version>
   </dependency> 

     <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-api</artifactId>
      <version>2.0.2</version>
   </dependency>
```

两个依赖添加上，我们就可以直接使用Swagger3的注解了

```java
@Tag(name = "用户管理")
@RestController
public class UserController {

    private final Logger logger = LoggerFactory.getLogger(UserController.class);

    @Operation(summary = "列表")
    @PostMapping("list")
    public ResultJson list() {
        ...
        return ResultJson.success();
    }

    @Operation(summary ="新增")
    @PostMapping("add")
    public ResultJson add(AdminRole AdminRole) {
       ...
        return ResultJson.success();
    }

    @Operation(summary ="修改")
    @PostMapping("update")
    public ResultJson update(AdminRole AdminRole) {
         ...
        return ResultJson.success();
    }

    @Operation(summary ="删除")
    @PostMapping("delete")
    public ResultJson delete(Integer id) {
           ...
        return ResultJson.success();
    }
}
```

从Springfox迁移过来的，需要修改注解：

- `@Api` → `@Tag`

- `@ApiIgnore` → `@Parameter(hidden = true)` or `@Operation(hidden = true)` or `@Hidden`

- `@ApiImplicitParam` → `@Parameter`

- `@ApiImplicitParams` → `@Parameters`

- `@ApiModel` → `@Schema`

- `@ApiModelProperty(hidden = true)` → `@Schema(accessMode = READ_ONLY)`

- `@ApiModelProperty` → `@Schema`

- `@ApiOperation(value = "foo", notes = "bar")` → `@Operation(summary = "foo", description = "bar")`

- `@ApiParam` → `@Parameter`

- `@ApiResponse(code = 404, message = "foo")` → `@ApiResponse(responseCode = "404", description = "foo")`

目前只用到了这些，这样启动项目就可以看到熟悉的界面了，后面用到什么再补充。
地址：http://ip:port/context-path/swagger-ui.html

![](C:\Users\20220509\AppData\Roaming\marktext\images\2023-02-20-10-20-15-image.png)

<img title="" src="file:///C:/Users/20220509/AppData/Roaming/marktext/images/2023-02-20-14-28-22-image.png" alt="" width="678">

- 创建一个filter，JwtAuthenticationFilter

- 创建JwtService

- 创建ApplicationConfig

- 创建SecurityConfiguration

# Vue3.0 创建项目

1、使用命令

npm init vite

![](C:\Users\20220509\AppData\Roaming\marktext\images\2023-02-27-15-28-33-image.png)

npm install

2、安裝依赖

Element-plus

npm i element-plus -S

安装插件

npm install unplugin-vue-components -D

配置按需导入：

vite.config.js配置文件：

增加：

import Components from 'unplugin-vue-components/vite'

import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

    Components({

      resolvers: [ElementPlusResolver()]

    })

最后完整配置：

```js
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'

// https://vitejs.dev/config/
export default defineConfig({
  server:{
    port: 9999
  },
  plugins: [
    vue(),
    Components({
      resolvers: [ElementPlusResolver()]
    })
  ],
})
```

3、测试

在首页使用element-plus的组件

```html
    <el-button>Default</el-button>
    <el-button type="primary">Primary</el-button>
    <el-button type="success">Success</el-button>
    <el-button type="info">Info</el-button>
    <el-button type="warning">Warning</el-button>
    <el-button type="danger">Danger</el-button>
```

重启项目，看到效果，有按钮

zhaoxi0061
