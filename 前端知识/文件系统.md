# 文件系统

## 读取文件

> Node操纵文件系统是通过一个重要原生模块来实现的：fs

```js
const fs= require('fs');

fs.readFile('./test.txt', 'utf8', function(error, data){
    if(error){
        console.log(error);
    }else{
        console.log(data);
    }
});
```

> 对于fs中的绝大多数api来说，Node都提供了相同功能的两个版本：同步版本与异步版本。
> 
> 对于同步版本与异步版本来说，其在方法的命名上存在一个规则：
> 
> xxx(异步)
> 
> xxxSync(同步)
> 
> 建议：尽最大可能去使用异步版本

```js
const fs= require('fs');
// 同步调用
try{
    const data = fs.readFileSync('test.txt','utf-8');
    console.log(data);
}catch(e){
    console.log(e);
}
```

## 写入文件

> 写入内容，如果文件不存则创建一个文件

```js
fs.writeFile('myTest.txt','hello world', function(error){
    if(error){
        return console.error(error);
    }

    console.log("success")
});
```

> 追加写入

```js
const fs =  require('fs');

fs.writeFile('test.txt', '你好', {flag:'a'}, function(error){
    if(error){
        return console.error(error);
    }
    console.log("success");
});
```

> 追加写入的另一种写法，调用appendFile

```js
const fs = require('fs');

fs.appendFile('test.txt', 'hello world\n', 'utf8', (error)=>{
    if(error){
        console.error(error);
    }else{
        console.log("success");
    }
});
```

## 打开文件

```js
const fs = require('fs');

// fd file descriptor 关闭的时候使用文件描述符
fs.open('test.txt', function(error, fd){
    if(error){
        return console.error(error);
    }
    console.log(fd);
    console.log("file is open");
});
```

## 文件关闭

```js
const fs = require('fs');

// fd file descriptor 关闭的时候使用文件描述符
fs.open('test.txt', function(error, fd){
    if(error){
        return console.error(error);
    }
    console.log(fd);
    console.log("file is open");

    fs.close(fd, function(error){

        if(error){
            console.error(error);
        }
        console.log("file is close");
    });
});
```

## 文件删除

```js
const fs = require('fs');

fs.unlink('test.txt', (error) =>{
    if(error){
        throw error;
    }

    console.log("file unlink");
});
```

## 文件重命名

```js
const fs = require('fs');

fs.rename("myTest.txt", "test.txt", (error)=>{
    if(error)
        throw error
    console.log('success');
});


fs.stat('test.txt', (error, stats)=>{
    if(error)
        throw error
    console.log(JSON.stringify(stats));
});
```

> 重命名以后读取，这样写是有问题的，因为上面的是异步调用所以有可能在下面方法执行后返回，这时候下面的程序会报异常。所以正确写法应该如下：

```js
const fs = require('fs');

fs.rename("myTest.txt", "test.txt", (error)=>{
    if(error)
        throw error
    console.log('success');

fs.stat('test.txt', (error, stats)=>{
    if(error)
        throw error
    console.log(JSON.stringify(stats));
});
});const fs = require('fs');

fs.rename("myTest.txt", "test.txt", (error) => {
    if (error)
        throw error
    console.log('success');


    fs.stat('test.txt', (error, stats) => {
        if (error)
            throw error
        console.log(JSON.stringify(stats));
    });
});
```

## 路径

```js
const path = require('path');

const myPath = path.join('/hello','/world','/c','/welcome','..');

console.log(myPath);
```

输出结果

```log
/hello/world/c
```

## 创建路径

```js
const fs = require('fs');
fs.mkdir('mdir/',(error) =>{
    if(error){
        throw error;
    }
    console.log("success");
});
```

## 创建嵌套目录层级

```js
const fs = require('fs');
fs.mkdir('mdir/hello/world',{recursive:true}, (error) =>{
    if(error){
        throw error;
    }
    console.log("success");
});
```

## 读取目录

```js
const fs = require('fs');
fs.readdir('./', (error, files)=>{
    if(error){
        console.error(error);
    }
    console.log(files);
});
```

## 检测文件是否存在

```js
const fs = require('fs');
fs.access('app0.js', (error)=>{
    if(error){
        console.log(error);
    }
    console.log("success");
});
```

## 通过相对路径获取绝对路径

```js
const fs = require('fs');
fs.realpath('app0.js', (error, resolvePath)=>{
    if(error){
        console.log(error);
    }else{
        console.log(resolvePath);
    }
});
```

## 删除目录

```js
const fs = require('fs');
fs.rmdir('mdir',{recursive: true}, (error)=>{
    if(error){
        console.error(error);
    }
    console.log("success");
});
```

## 流处理文件

### 流读取文件

```js
// 读取大文件
const fs = require('fs');
const readStream = fs.createReadStream('app0.js',{encoding:'utf-8'});

readStream.on('open',(fd)=>{
    console.log(fd);
});

readStream.on('ready',()=>{
    console.log("ready");
});

readStream.on('data',(data)=>{
    console.log(data);
});

readStream.on('error',(error)=>{
    console.log(error);
});

readStream.on('close',()=>{
    console.log('close');
});
```

### 流写入文件

```js
const fs = require("fs");
const readStream = fs.createReadStream('app1.js', {encoding:"utf-8"});

const writeStream = fs.createWriteStream('write.txt',{encoding:"utf-8"});

readStream.on('data', (data)=>{
    writeStream.write(data, (error)=>{
        if(error){
            console.log(error)
        }else{
            console.log(data);
        }
    });
});
```

## 引入第三方模块

#### 1. 用npm安装

> 例如引入uuid模块
> 
> npm install uuid 执行这个命令会安装uuid最新版本

#### 2. 引入模块

```js
const {v4:uuidv5} = require('uuid');
console.log(uuidv5());
```
