# Node底层事件与异步操作

> - Node 本身能够做到如此高性能的根本原因在于事件（event）的使用，以及对于事件监听者（listener，callback）的调用上
> 
> - Node本身是基于事件循环机制的。
> 
> - 本质上，Node启动一个文件或者服务器后，Node实际上是运行在一个死循环中的。
> 
> - 在这个死循环当中，Node会不断的发射事件、监听事件并且执行回调逻辑。
> 
> - 事件来源主要有两种：一是Node自身所发射的事件，二是来自于Node自身所运行的环境。
> 
> - 监听事件：回调都是要依附于相应的事件的。
> 
> - 执行回调逻辑：本质上都是有底层（操作系统或者是c++代码）来执行的。

> 关于IO操作的异步执行逻辑:
> 
> 异步模式：poll，epoll，在windows当中用的是操作系统的IOCP

- Node的单线程：所谓单线程，值得是Node的逻辑执行主线程是单线程的，即JavaScript代码运行所处的线程，这个是单线程，因为javaScript本身不能运行在多线程中的。

- 文件：并不是单单指能看到的文件。例如：socket也会被linux看作是一个文件。

> 当我们在程序中引入了某个第三方模块时，那么整体的全部执行逻辑如下所示：
> 
> Node -> 第三方模块 -> 原生模块-> 原生模块的内部的实现  ->  c++模块 ->libuv(操作系统)  ->线程池（IO线程池） ->选取一个可用线程 ->执行底层的IO操作（涉及到操作系统调用）。

当node在执行过程中，他会判断当前的操作系统类型。

> Node 完整的事件循环逻辑
> 
> 1. 启动Node运行时
> 
> 2. 检测是否有待处理的事件
> 
> 3. 如果没有，回到循环开始 
> 
> 4. 如果有，那么从事件列表中取出一个事件
> 
> 5. 判断当前这个事件有没有与之关联的事件处理器（回调）
> 
> 6. 过没有回调循环开始
> 
> 7. 如果有，则执行事件的回调逻辑
> 
> 8. 回到循环开始，开始新一轮的事件监测流程

整个Node对执行过程实际上是由完整的事件内循环机制+底层的操作系统异步IO调用+线程池（底层库实现或由操作系统提供）共同配合完成的。

> 对于单线程的Node来说，是否无法利用到多核的优势呢？

对于Node的主线程来说，它只能运行在一个核心上面。

对于底层线程池来说，他们可以运行在多个核心上面，当然也可以同时运行，因此他们是完全可以利用到多核的优势的。
